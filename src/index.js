import { when } from 'https://esm.run/lit-html/directives/when.js';
import { asyncAppend } from 'https://esm.run/lit-html/directives/async-append.js';
import { ref, createRef } from 'https://esm.run/lit-html/directives/ref.js';

import * as history from './historyStorage.js';
import { createReplaceable, replaceable } from './replaceable.js';
import { URL, LIST_NAME, agent, listRecords, blockNSID, listItemNSID } from './common.js';
import { html, centerText, startApp, logout } from './app.js';

let targetUrl;

const postInput = createRef();
const postInputBox = html`<div class="box">
		<input ${ref(postInput)} type="text" name="posturl" placeholder="post url">
		<div class="row">
			<button @click=${() => getlikers('app.bsky.feed.getRepostedBy', x => x.repostedBy)}>get reposters</button>
			<button @click=${() => getlikers('app.bsky.feed.getLikes', x => x.likes.map(l => l.actor))}>get likers</button>
		</div>
		<button @click=${() => logout(() => main.replace(loginBox))}>logout</button>
	</div>`;

var { loginBox, main } = startApp(postInputBox);

async function createAll(records) {
	if (records.length === 0) return;

	records.forEach(r => {
		r['$type'] = 'com.atproto.repo.applyWrites#create';
	});

	const batchSize = 200;
	const amm = records.length;
	for (let i = 0; i < amm; i += batchSize) {
		await agent.rpc.call('com.atproto.repo.applyWrites', {
			data: {
				repo: agent.session.did,
				writes: records.slice(i, i + batchSize)
			}
		})
	}
}

async function recordExists(repo, collection, rkey) {
	try {
		await agent.rpc.get('com.atproto.repo.getRecord', {
			params: { repo, collection, rkey }
		})
		return true;
	} catch {
		return false;
	}
}

const doneRow = html`<div class="row">
		${centerText("Done!")}
		<button @click=${() => main.replace(postInputBox)}>back</button>
	</div>`;

async function blockall(likers, deselected, actionRow) {
	let records = [];

	actionRow.replace(centerText("Processing..."));

	const createdAt = (new Date()).toISOString();

	likers.filter((_,i) => !deselected[i]).forEach(actor => {
		if (!actor.viewer.blocking) {
			records.push({
				collection: blockNSID,
				value: {
					'$type': blockNSID,
					subject: actor.did,
					createdAt
				}
			});
		}
	});

	history.add({
		collection: blockNSID,
		timestamp: createdAt,
		recordCount: records.length,
		targetUrl
	});

	actionRow.replace(centerText("Creating blocks..."));

	await createAll(records);

	actionRow.replace(doneRow);
}

async function muteall(likers, deselected, actionRow) {
	const repo = agent.session.did;
	let records = [];

	actionRow.replace(centerText("Processing..."));

	const createdAt = (new Date()).toISOString();

	const listType = 'app.bsky.graph.list';
	const listRkey = 'bblock';
	const listExists = await recordExists(repo, listType, 'bblock');
	if (!listExists) {
		records.push({
			collection: listType,
			rkey: listRkey,
			value: {
				'$type': listType,
				purpose: 'app.bsky.graph.defs#modlist',
				name: LIST_NAME,
				description: 'automatically generated by '+URL,
				createdAt
			}
		});
	}

	const list = `at://${repo}/${listType}/${listRkey}`;

	likers.filter((_,i) => !deselected[i]).forEach(actor => {
		if (!actor.viewer.muted) {
			records.push({
				collection: listItemNSID,
				value: {
					'$type': listItemNSID,
					subject: actor.did,
					list,
					createdAt
				}
			});
		}
	});

	history.add({
		collection: listItemNSID,
		timestamp: createdAt,
		recordCount: records.length,
		targetUrl
	});

	actionRow.replace(centerText("Creating mutes..."));

	await createAll(records);

	await new Promise(r => setTimeout(r, 100));

	const listBsky = `https://bsky.app/profile/${repo}/lists/${listRkey}`;
	const createdMessage = when(listExists, () => html``, () => html`It was automatically created for use by this tool. You may change its name and avatar.`);
	actionRow.replace(html`<div class="box">${doneRow}
			<p>Users were added to the <a href=${listBsky} target="_blank">${LIST_NAME}</a> mute list.
			${createdMessage}
			You must subscribe to this list for the mutes to enter into effect.</p>
		</div>`);
}

async function* withCopyTo(arr, gen) {
	for await (const v of gen()) {
		arr.push(v);
		yield v;
	}
}

let following;
async function getlikers(rpc, f) {
	const actionRow = createReplaceable(centerText("Loading..."));

	if (following === undefined) {
		following = {};
		for await (const x of listRecords('app.bsky.graph.follow')) {
	        following[x.value.subject] = true;
	    }
	    following[agent.session.did] = true;
	}

	let profileRefs = [];
	let likers = [];
	let deselected = {};

	targetUrl = postInput.value.value;
	const g = targetUrl.match(/^https:\/\/bsky\.app\/profile\/(.+?)\/post\/([^/]+)/);

	if (!g || g.length < 3) {
		main.replace(html`<div class="box">
				${centerText("Invalid Bluesky post URL")}
				<button @click=${() => main.replace(postInputBox)}>back</button>
			</div>`);
		return;
	}

	let did = g[1];
	if (!g[1].startsWith("did:")) {
		const res = await agent.rpc.get('com.atproto.identity.resolveHandle', {
			params: {
				handle: g[1]
			}
		});
		did = res.data.did;
	}

	const PAGE_LIMIT = 100;
	async function fetchPage(cursor) {
		return await agent.rpc.get(rpc, {
			params: {
				uri: `at://${did}/app.bsky.feed.post/${g[2]}`,
				limit: PAGE_LIMIT,
				cursor: cursor,
			},
		});
	}

	async function* pages() {
		let res = await fetchPage();
		let page = f(res.data);

		yield* page;

		while (res.data.cursor && page.length >= PAGE_LIMIT) {
			res = await fetchPage(res.data.cursor);
			page = f(res.data);

			yield* page;
		}

		actionRow.replace(html`<div class="row">
				<button @click=${() => muteall(likers, deselected, actionRow)} style="flex:2">mute all</button>
				<button @click=${() => blockall(likers, deselected, actionRow)} style="flex:1">block all</button>
				<button @click=${() => main.replace(postInputBox)} style="flex:1">back</button>
			</div>`);
	}

	const profile = (actor, index) => {
		const _ref = createRef();

		const select = () => {
			deselected[index] = !deselected[index];
			_ref.value.className = deselected[index] ? "profile deselected" : "profile";
		};

		if (following[actor.did]) {
			deselected[index] = true;
		}

		return html`<div ${ref(_ref)} class="${when(deselected[index], () => "profile deselected", () => "profile")}">
				<img src=${actor.avatar} />
				<div style="flex:1">
					<p>${actor.displayName}</p>
					<p>${actor.description}</p>
				</div>
				<button @click=${select} class="squarebutton">X</button>
			</div>`;
	};

	main.replace(html`<div class="box" style="display:flex">
			${replaceable(actionRow)}
			${asyncAppend(withCopyTo(likers, pages), profile)}
		</div>`);
}
