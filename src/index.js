import { when } from 'https://esm.run/lit-html/directives/when.js';
import { asyncAppend } from 'https://esm.run/lit-html/directives/async-append.js';
import { ref, createRef } from 'https://esm.run/lit-html/directives/ref.js';

import * as history from './historyStorage.js';
import { createReplaceable, replaceable } from './replaceable.js';
import { URL, LIST_NAME, agent, listRecords, blockNSID, listItemNSID } from './common.js';
import { html, centerText, startApp, logout } from './app.js';
import { listSelect } from './listSelect.js';

let targetUrl;

const postInput = createRef();
const profileInput = createRef();

const startBox = html`<div class="box">
		<input ${ref(postInput)} type="text" name="posturl" placeholder="post url">
		<div class="row">
			<button @click=${() => getlikers('app.bsky.feed.getRepostedBy', x => x.repostedBy)}>get reposters</button>
			<button @click=${() => getlikers('app.bsky.feed.getLikes', x => x.likes.map(l => l.actor))}>get likers</button>
		</div>
		<hr>
		<input ${ref(profileInput)} type="text" name="profileurl" placeholder="profile url">
		<div class="row">
			<button @click=${() => getlikers('app.bsky.graph.getFollowers', x => x.followers)}>get followers</button>
			<button @click=${() => getlikers('app.bsky.graph.getFollows', x => x.follows)}>get following</button>
		</div>
		<hr>
		<button @click=${() => logout(() => main.replace(loginBox))}>logout</button>
	</div>`;

var { loginBox, main } = startApp(startBox);

async function createAll(records) {
	if (records.length === 0) return;

	records.forEach(r => {
		r['$type'] = 'com.atproto.repo.applyWrites#create';
	});

	const batchSize = 10;
	const amm = records.length;
	for (let i = 0; i < amm; i += batchSize) {
		await agent.rpc.call('com.atproto.repo.applyWrites', {
			data: {
				repo: agent.session.did,
				writes: records.slice(i, i + batchSize)
			}
		});
		await new Promise(r => setTimeout(r, 1000)); // TODO: proper rate limiting
	}
}

async function recordExists(repo, collection, rkey) {
	try {
		await agent.rpc.get('com.atproto.repo.getRecord', {
			params: { repo, collection, rkey }
		})
		return true;
	} catch {
		return false;
	}
}

const doneRow = html`<div class="row">
		${centerText("Done!")}
		<button @click=${() => main.replace(startBox)}>back</button>
	</div>`;

async function blockall(likers, deselected, actionRow) {
	let records = [];

	actionRow.replace(centerText("Processing..."));

	const createdAt = (new Date()).toISOString();

	likers.filter((_,i) => !deselected[i]).forEach(actor => {
		if (!actor.viewer.blocking) {
			records.push({
				collection: blockNSID,
				value: {
					'$type': blockNSID,
					subject: actor.did,
					createdAt
				}
			});
		}
	});

	history.add({
		collection: blockNSID,
		timestamp: createdAt,
		recordCount: records.length,
		targetUrl
	});

	actionRow.replace(centerText("Creating blocks..."));

	await createAll(records);

	actionRow.replace(doneRow);
}

const listRkey = 'bblock';
function listCreateRecord() {
	const createdAt = (new Date()).toISOString();

	return [ `at://${repo}/app.bsky.graph.list/${listRkey}`, {
			collection: 'app.bsky.graph.list',
			rkey: listRkey,
			value: {
				'$type': 'app.bsky.graph.list',
				purpose: 'app.bsky.graph.defs#modlist',
				name: LIST_NAME,
				description: 'automatically generated by '+URL,
				createdAt
			}
		} ];
}

async function muteall(likers, list, deselected, actionRow) {
	const repo = agent.session.did;
	let records = [];

	actionRow.replace(centerText("Processing..."));

	const createdAt = (new Date()).toISOString();

	let listExists = true;
	if (list == "create") {
		listExists = await recordExists(repo, 'app.bsky.graph.list', listRkey);
		const [ _list, listRecord ] = listCreateRecord();
		if (!listExists)
			records.push(listRecord);
		list = _list;
	}

	likers.filter((_,i) => !deselected[i]).forEach(actor => {
		if (!actor.viewer.muted) {
			records.push({
				collection: listItemNSID,
				value: {
					'$type': listItemNSID,
					subject: actor.did,
					list,
					createdAt
				}
			});
		}
	});

	history.add({
		collection: listItemNSID,
		timestamp: createdAt,
		recordCount: records.length,
		targetUrl
	});

	actionRow.replace(centerText("Creating list items..."));

	await createAll(records);

	await new Promise(r => setTimeout(r, 100));

	actionRow.replace(html`<div class="box">${doneRow}
			<p>Users were added to the mute list. You must subscribe to this list to mute these users.</p>
		</div>`);
}

async function* withCopyTo(arr, gen) {
	for await (const v of gen()) {
		arr.push(v);
		yield v;
	}
}

let following;
async function getlikers(rpc, f) {
	const actionRow = createReplaceable(centerText("Loading..."));

	const listSelector = listSelect(true);

	if (following === undefined) {
		following = {};
		for await (const x of listRecords('app.bsky.graph.follow')) {
	        following[x.value.subject] = true;
	    }
	    following[agent.session.did] = true;
	}

	let likers = [];
	let deselected = {};

	const isGraph = rpc.indexOf("graph") !== -1;

	targetUrl = (isGraph ? profileInput : postInput).value.value;
	const g = targetUrl.match(isGraph ? /^(?:https:\/\/bsky\.app\/profile\/|(?=did:plc:))([^/]+)/ : /^https:\/\/bsky\.app\/profile\/([^/]+?)\/post\/([^/]+)/);

	if (!g || g.length < 2) {
		main.replace(html`<div class="box">
				${centerText("Invalid Bluesky URL")}
				<button @click=${() => main.replace(startBox)}>back</button>
			</div>`);
		return;
	}

	let did = g[1];
	if (!isGraph && !g[1].startsWith("did:")) {
		const res = await agent.rpc.get('com.atproto.identity.resolveHandle', {
			params: {
				handle: g[1]
			}
		});
		did = res.data.did;
	}

	const PAGE_LIMIT = 100;
	async function fetchPage(cursor) {
		const params = { limit: PAGE_LIMIT, cursor: cursor };

		if (isGraph) {
			params.actor = did;
		} else {
			params.uri = `at://${did}/app.bsky.feed.post/${g[2]}`;
		}

		return await agent.rpc.get(rpc, { params });
	}

	async function* pages() {
		let res = await fetchPage();
		let page = f(res.data);

		yield* page;

		while (res.data.cursor && page.length >= PAGE_LIMIT) {
			res = await fetchPage(res.data.cursor);
			page = f(res.data);

			yield* page;
		}

		actionRow.replace(html`<div class="row">
				<button @click=${() => muteall(likers, listSelector.selected.last, deselected, actionRow)} style="flex:2">add all to list</button>
				<button @click=${() => blockall(likers, deselected, actionRow)} style="flex:1">block all</button>
				<button @click=${() => main.replace(startBox)} style="flex:1">back</button>
			</div>`);
	}

	const profile = (actor, index) => {
		const _ref = createRef();

		const select = () => {
			deselected[index] = !deselected[index];
			_ref.value.className = deselected[index] ? "profile deselected" : "profile";
		};

		if (following[actor.did]) {
			deselected[index] = true;
		}

		return html`<div ${ref(_ref)} class="${when(deselected[index], () => "profile deselected", () => "profile")}">
				<img src=${actor.avatar} />
				<div style="flex:1">
					<p>${actor.displayName}</p>
					<p>${actor.description}</p>
				</div>
				<button @click=${select} class="squarebutton">X</button>
			</div>`;
	};

	main.replace(html`<div class="box" style="display:flex">
			${listSelector.selector}
			${replaceable(actionRow)}
			${asyncAppend(withCopyTo(likers, pages), profile)}
		</div>`);
}
